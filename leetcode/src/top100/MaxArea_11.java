package top100;

/*
给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个】
端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。

图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

 

示例：

输入：[1,8,6,2,5,4,8,3,7]
输出：49

分析：
暴力法：前后选择两条线，计算结果，最终取最大值 时间复杂度O(N2)
双指针法：
i指向最左边，j 指向最右边；
若 arr[i] <= arr[j]
    记录 max(i, j)
    i ++
否则
    记录 max(i,j)
    j --;
直到 i == j 结束

证明：
对应 [1,8,6,2,5,4,8,3,7]
第一步 i=0，j=8；此时的面积等于 底 * 高；此时 i 柱子和短柱子，j 柱子是长柱子；
假设 j 柱子向左移动，那么 相比上一步，底的长度减少1，移动后的水位高度不会超过原来的高度；面积一定减少
假设 i 柱子向左移动，底减少了，但是高可能增加，最终反映的是面积可能增加或者减少
所以我们移动短柱子，那么 怎么证明移动不会错过解呢？
解空间排除法，二维矩阵解空间，对于这个问题，  0<=i<=8 0<=j<=8 有效解空间是  i<j   0<=i<=8  0<=j<=8 其实是上三角
最开始在 (0，8) 处，设右边高，左边低， j --，则 (0, 7) 处的值一定小于当前获得的值，同理可以排除 (0,6)....第一行
i ++ 后，到达 (1,8) 位置，设左边高，固定左边，那么可以排除 i = 2， 3， .. 这一列
以此类推，每一步移动指针都会缩减解空间，最终一定可以遍历完了解空间，过程中记录了值，所以不会错过最大值

但是若 出现 左右两根柱子一样长的问题怎么办？
此时两根柱子相等，随便移动一根？为什么可以，两根柱子相等，那么无论移动那一根，都是会使得结果小于上一次；也是可以排除一行或者一列的解位置



 */
public class MaxArea_11 {

    public int maxArea(int[] height) {
        int max = Integer.MIN_VALUE;

        int i = 0, j = height.length - 1;
        int curCap;
        while (i < j) {
//            curCap = (height[j] - height[i]) * Math.min(height[i], height[j]);
            // 面积= 底 * 高 底的计算使用的是下标
            curCap = (j - i) * Math.min(height[i], height[j]); // 当前两根柱子之间的水容量
            max = Math.max(max, curCap);
            if (height[i] <= height[j]) {// 每次移动短柱子，向可能的解靠近；若移动长柱子，容量一定减少，不会靠近解
                i ++;
            } else {
                j --;
            }
        }

        return max;
    }
}
