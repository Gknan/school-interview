package top100;

/*
给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
示例 1:
输入: [3,2,3]
输出: 3

示例 2:
输入: [2,2,1,1,1,2,2]
输出: 2

分析：
1 借助Map，遍历一遍数组，存储每个数字出现的次数；遍历一遍 mao，找到value 满足条件的key
2 指针法 Boyer-Moore 投票算法
先遍历一遍找到最有可能的元素，然后遍历一遍判断是否满足；
3 排序法：排序后，数组的 n/2 位置就是结果
4 转换成求 n/2 大元素，冒泡 快速排序 找到 第 n/2 个元素
5 随机化，超过 n/2 个元素是一样的，随机找一个数字，遍历判断是否超过 n/2


Boyer-Moore 投票算法
如果我们把众数记为 +1 ，把其他数记为 -1 ，将它们全部加起来，显然和大于 0 ，从结果本身我们可以看出众数比其他数多。
本质上， Boyer-Moore 算法就是找 nums 的一个后缀 suf ，其中 suf[0] 就是后缀中的众数。我们维护一个计数器，
如果遇到一个我们目前的候选众数，就将计数器加一，否则减一。只要计数器等于 0 ，我们就将 nums 中之前访问的数字全部 忘记 ，并把下一个数字当做候选的众数。
此时，我们的候选者并不是真正的众数，但是我们在 遗忘 前面的数字的时候，要去掉相同数目的众数和非众数（如果遗忘更多的非众数，会导致计数器变成负数）。
因此，上面的过程说明了我们可以放心地遗忘前面的数字，并继续求解剩下数字中的众数。最后，总有一个后缀满足计数器是大于 0 的，此时这个后缀
的众数就是整个数组的众数。


分治法思想：
长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1 ，我们必须将左右子区间的值合并。如果它们的众数相同，
那么显然这一段区间的众数是它们相同的值。
否则，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数
 */
public class MajorityElement_169 {
    public static int majorityElement(int[] nums) {

        int prob = 0;
        int cnt = 0;

        for (int i = 0; i < nums.length; i ++) {
            if (cnt == 0) {
                prob = nums[i];
                cnt = 1;
                continue;
            }

            if (nums[i] == prob) {
                cnt ++;
            } else {
                cnt --;
            }
        }

        return prob;
    }

    public static void main(String[] args) {
        int[] nums = {2,2,1,1,1,2,2};
        System.out.println(majorityElement(nums));
    }
}
